@page
@model CleanArchitecture.ClientWeb.Pages.AboutModel
@{
    ViewData["Title"] = "About";
}

    <div class="row">
        <div class="col-md-12 mb-1">
            <img src="~/images/about_header.jpg" class="img-fluid" height="300" />
            <small class="float-right text-muted">"Mountain Retreat" - Bob Ross</small>
        </div>
        <div class="col-md-12">
            <h1>The motivation behind it all</h1>
            <p>What is the point of all this? Well, besides showcasing Bob Ross... I thought it would be clever to have a "real world" application to reference when talking architecture. I want something to set a standard, something to clone, something to utilize in all my next .Net Core projects. Like all software (and wine), this will improve with time.</p>
        </div>
        <div class="col-md-12">
            <h2>Key Points:</h2>
            <br />
            <h4>N-Tier Architecture</h4>
            <p>A 3 layered approach, to set us up for multiple UI's that use the same core business functionality/back-end.&nbsp;</p>
            <h4>Separation of Concerns</h4>
            <p>Closely related to the <a href="http://deviq.com/single-responsibility-principle/">"Single Responsibility"</a> principle, Separation of Concerns (SoC) makes your code more maintainable, by not co-locating ideas. When things change, SoC will help ensure your changes are limited to your feature set, and not spread throughout your application.</p>
            <h4>No Leaky Abstractions</h4>
            <p>By using interfaces, we can avoid leaky abstractions, and have better control of how our code is used. On the contrary, consumers of our code don't have to know the implementation details, they can simply use your interfaces/classes.</p>
            <h4>Testable</h4>
            <p>Testing code that is tightly coupled is nearly impossible. By following the SOC principal, and using interfaces our code will be easier to rest in result. </p>
            <h4>Modular</h4>
            <p>The code will be easier to modify in the future, because of a few reasons. Separation of concerns allows for fewer changes/testing throughout the application. You can build on specific feature sets, without modifying the rest of the code.</p>
            <h4>Maintainable</h4>
            <p>The code will inheritenly be more maintainable by following Clean Architecture patterns. Other developers will see the benefit of the clean separation, and follow suit.</p>
        </div>
        <div class="col-md-12">
            <h2>Technologies Used:</h2>
            <br />
            <ul>
                <li><a class="" href="https://dotnet.microsoft.com/" target="_blank">.Net Core</a> <small class="text-muted">(@Model.VersionInfo)</small></li>
                <li><a class="" href="https://www.learnrazorpages.com/" target="_blank">Razor Pages</a></li>
                <li><a class="" href="https://docs.microsoft.com/en-us/ef/core/" target="_blank">Entity Framework Core</a></li>
                <li><a class="" href="https://automapper.org/" target="_blank">AutoMapper</a></li>
                <li><a class="" href="https://nlog-project.org/" target="_blank">NLog</a></li>
                <li><a class="" href="https://getbootstrap.com/" target="_blank">Bootstrap</a></li>
                <li><a class="" href="https://fontawesome.com/" target="_blank">FontAwesome</a></li>
            </ul>
        </div>
    </div>